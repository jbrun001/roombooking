require("dotenv").config();
const express = require("express");
const app = express();
const port = process.env.PORT || 8000;
var session = require("express-session"); // used for creating sessions so data can persist between pages like if a user is logged in
const mysql = require("mysql2");
var ejs = require("ejs");
const sanitiseHtml = require("sanitize-html"); // used to make sure there are no cross site scripting issues with the input
const bodyParser = require("body-parser");
const bcrypt = require("bcrypt"); // used for storing and comparing password hashes
const bcryptSaltRounds = 10; // the higher this is the more processing time - 20 is unworkable takes too long so changed to 10

// set up the database connection
const db = mysql.createConnection(process.env.DATABASE_URL);
db.connect();

// session middleware - used for login, used to create a unique persistent session
app.use(
  session({
    secret: "secretforumkey",
    resave: false,
    saveUninitialized: true,
    cookie: {
      sameSite: "strict",
    },
  })
);

// this allows processing of form data
app.use(bodyParser.urlencoded({ extended: true }));

// Set the directory where Express will pick up media files images - this will be accessable from \
// __dirname will get the current directory
app.use(express.static(__dirname + "/media"));

// Set up access to folder with css
app.use(express.static(__dirname + "/public"));

// Set the security headers for anti-click jacking and set the content security policy
// these fix 2 medium security errors identified by OWASP Zap as part of Part E
app.use((req, res, next) => {
  // this is a very restrictive header only pages generated by this app.js. no plugins are allowed and no base tags are allowed
  const origin = req.headers.origin;
  // week 4 security policies
  var cSPolicy = "default-src http://localhost:8000; "; // will need changing when installed
  cSPolicy =
    cSPolicy +
    "script-src http://localhost:8000 'unsafe-inline' https://ajax.googleapis.com; "; // unsafe-inline allows for script in the pages
  cSPolicy =
    cSPolicy +
    "img-src 'self' https://cdn3.iconfinder.com https://i.imgur.com; ";
  cSPolicy = cSPolicy + "style-src http://localhost:8000; ";
  cSPolicy = cSPolicy + "font-src http://localhost:8000; ";
  cSPolicy = cSPolicy + "frame-ancestors http://localhost:8000; "; // stops the page being used within external websites
  cSPolicy = cSPolicy + "form-action http://localhost:8000; "; // only allow form submission to the server running the app
  res.setHeader("Content-Security-Policy", cSPolicy);
  res.removeHeader("X-Powered-By"); // was telling attackers we are using Express
  // week 5 security changes
  res.setHeader("X-Frame-Options", "SAMEORIGIN");
  res.setHeader("X-Content-Type-Options", "nosniff");
  // week 6 security changes CORS stop the server getting requests from pages that are not generated from the server
  res.setHeader("Access-Control-Allow-Origin", "http://localhost:8000");
  // restrict the types of access methods we allow - only need get and post, not options, put or delete
  res.setHeader("Access-Control-Allow-Methods", "GET, POST");
  res.setHeader(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, X-Requested-With, If-Modified-Since"
  );

  next(); // Pass control to the next middleware or route handler
});

// Set the directory where Express will pick up HTML files
// __dirname will get the current directory
app.set("views", __dirname + "/views");

// Tell Express that we want to use EJS as the templating engine
app.set("view engine", "ejs");

// Tells Express how we should process html files
// We want to use EJS's rendering engine
app.engine("html", ejs.renderFile);

// function to hash a plain text password
function hashPassword(password) {
  try {
    var hash = bcrypt.hashSync(password, bcryptSaltRounds);
    return hash;
  } catch (error) {
    return null;
  }
}

// function to hash a plain text password
function isMatchingPassword(password, hashedPassword) {
  try {
    // Compare the provided password with the hashedPassword
    const match = bcrypt.compareSync(password, hashedPassword);
    return match;
  } catch (error) {
    return false;
  }
}

// this is used to display the currently logged in user in the top right of the form
function getLoggedInUser(req) {
  if (req.session && req.session.isLoggedIn) {
    return "logged in as " + req.session.email;
  } else {
    return "not logged in";
  }
}

// function to check if user is logged in - if they are not returns them to the home page (where the login form is)
// this is used in multiple routes eg. addpost, deletepost - so users cannot access those pages
// if not logged in
function isLoggedIn(req, res, next) {
  if (req.session && req.session.isLoggedIn)
    next(); // if user logged in then carry on in the route
  else {
    loggedInMessage = "not logged in";
    res.render("login.ejs", { loggedInMessage }); // if user is not logged in take them to the login page
  }
}

app.get("/", (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  res.render("login.ejs", { loggedInMessage });
});

app.get("/login", (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  res.render("login.ejs", { loggedInMessage });
});

// login-check route which is the target for the https post in login,ejs.ejs
app.post("/login-check", function (req, res) {
  var email = sanitiseHtml(req.body.email);
  var password = req.body.password;
  // just check that the email address exists (password hash checking comes after)
  let sqlquery =
    'SELECT email, id, password, user_role FROM user_account WHERE email="' +
    email.toLowerCase() +
    '";';
  db.query(sqlquery, (err, result) => {
    // if error display login-error page
    loggedInMessage = getLoggedInUser(req);
    if (err) {
      console.error(err.message);
      res.render("login-error.ejs", { loggedInMessage });
    } else if (result === null || result.length === 0) {
      // no matching records at all
      console.error("user not found");
      res.render("login-error.ejs", { loggedInMessage });
    }
    // if this is a valid user
    else {
      // now have to check the passwords matches the hashed password
      // take the first result from the sql query
      if (isMatchingPassword(password, result[0].password)) {
        req.session.isLoggedIn = true; // set the session variable to show logged in
        req.session.userid = result[0].id;
        req.session.email = result[0].email;
        req.session.user_role = result[0].user_role;
        loggedInMessage = getLoggedInUser(req);
        res.redirect("/login-success");
      } else {
        console.error("user details don't match");
        loggedInMessage = getLoggedInUser(req);
        res.render("login-error.ejs", { loggedInMessage });
      }
    }
  });
});

app.get("/login-error", function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  res.render("login-error.ejs", { loggedInMessage });
});

app.get("/logout", function (req, res) {
  req.session.destroy((err) => {
    if (err) {
      console.error("Error destroying session:", err);
      res.sendStatus(500); // Internal Server Error
    } else {
      loggedInMessage = "not logged in";
      res.render("login.ejs", { loggedInMessage });
    }
  });
});

// register page route - registers a new user and adds them as a member to the first topic
// so they are able to post somewhere when they first join
app.get("/register", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  sqlquery = "select * from lookup_user_role";
  // execute sql query
  db.query(sqlquery, (err, data) => {
    if (err) {
      res.redirect("./");
      return console.error(err.message);
    }
    let newData = Object.assign(
      {},
      { loggedInMessage },
      { userrole },
      { email },
      { allUserRoles: data }
    );
    res.render("register.ejs", newData);
  });
});
// the form in register.ejs has a target of /registered which will get managed by this code.
// this form uses http POST
app.post("/registered", isLoggedIn, function (req, res) {
  // before we send the input fields which will be displayed on the page
  // make sure they don't contain any dangerous HTML for cross site scripting
  var email = sanitiseHtml(req.body.email);
  var password = sanitiseHtml(req.body.password);
  var userrole = sanitiseHtml(req.body.userrole);
  var societyname = sanitiseHtml(req.body.societyname);
  var module = sanitiseHtml(req.body.module);
  var hashedPassword = hashPassword(password);
  let sqlqueryuser =
    "INSERT INTO user_account (email, password, user_role, society_name, module) VALUES (?,?,?,?,?)";
  // execute sql query
  let newuser = [
    email.toLowerCase(),
    hashedPassword,
    userrole,
    societyname,
    module,
  ];
  db.query(sqlqueryuser, newuser, (err, result) => {
    // if error display login page
    if (err) {
      res.redirect("/");
      return console.error(err.message);
    } else {
      res.redirect("/login-success");
    }
  });
});

app.get("/credits", (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  res.render("credits.ejs", { loggedInMessage });
});

app.get("/faq", (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  res.render("faq.ejs", { loggedInMessage });
});

// this route is the template for all pages when the user is logged in
// there is an extra check to make sure that the user is currently logged in
// before displaying this route
app.get("/login-success", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  //console.log(loggedInMessage + " " + userrole);
  res.render("login-success.ejs", { loggedInMessage, userrole, email });
});

/* this is the original get bookings the new version is immediately below - keeping this code
// here temporarily in case we need to swap back
// get booking data from the database
function getBookings(pageName,userId) {
  return new Promise((resolve, reject) => {
    sqlquery = "";
    if (pageName === "bookings-list") {
      // only get the room types that the logged in user has made bookings for
      sqlquery = `
        SELECT 
          r.room_number as roomNumber, r.building_name as building, r.capacity as minSeats,
          r.room_type as roomType, DATE_FORMAT(b.booking_start, '%Y-%m-%d') as date,
          CONCAT(DATE_FORMAT(b.booking_start, '%H'),':',DATE_FORMAT(b.booking_start,'%i'),'-',DATE_FORMAT(b.booking_end, '%H'),':',DATE_FORMAT(b.booking_end,'%i')) as timeslot,
          r.picture_URL as pictureURL, u.email as bookedBy, b.booking_status as Status,
          b.id as bookingId, r.id as roomId, u.id as userId
        FROM booking b JOIN room r ON b.room_id = r.id JOIN user_account u ON b.user_id = u.id
        WHERE u.id = ?
        ORDER BY b.booking_status, b.booking_start desc`
    } else {
      // get all bookings from any user
      sqlquery = ` 
        SELECT  r.room_number as roomNumber, r.building_name as building, r.capacity as minSeats,
          r.room_type as roomType, DATE_FORMAT(b.booking_start, '%Y-%m-%d') as date,
          CONCAT(DATE_FORMAT(b.booking_start, '%H'),':',DATE_FORMAT(b.booking_start,'%i'),'-',DATE_FORMAT(b.booking_end, '%H'),':',DATE_FORMAT(b.booking_end,'%i')) as timeslot,
          r.picture_URL as pictureURL, u.email as bookedBy, b.booking_status as Status, 
          b.id as bookingId, r.id as roomId, u.id as userId
        FROM booking b JOIN room r ON b.room_id = r.id JOIN user_account u ON b.user_id = u.id
        ORDER BY b.booking_status, b.booking_start desc`
    }
    // execute sql query
    db.query(sqlquery, [userId], (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err);        // if there is an error reject the Promise
      } else {
        resolve(results);   // the Promise is resolved with the result of the query
      }
    });
  });
}
*/

// getBookings - revised edition
// this can be called by any page that displays a list of booking
// add additional if (pageName === 's to change the base SQL to include different criteria for different lists
// for example the "bookings-list" criteria only shows those bookings for the current user
// but that might not be what's needed for other pages.  The rest of the code stays the same.
function getBookings(pageName, userId, filters, listOrder) {
  return new Promise((resolve, reject) => {
    sqlquery = "";
    if (pageName === "bookings-list") {
      // this is the base query all additionl filters will be appended later in the code
      sqlquery = `
        SELECT 
        r.room_number as roomNumber, r.building_name as building, r.capacity as minSeats,
        r.room_type as roomType, DATE_FORMAT(b.booking_start, '%Y-%m-%d') as date,
        CONCAT(DATE_FORMAT(b.booking_start, '%H'),':',DATE_FORMAT(b.booking_start,'%i'),'-',DATE_FORMAT(b.booking_end, '%H'),':',DATE_FORMAT(b.booking_end,'%i')) as timeslot,
        r.picture_URL as pictureURL, u.email as bookedBy, b.booking_status as Status,
        b.id as bookingId, r.id as roomId, u.id as userId
        FROM booking b JOIN room r ON b.room_id = r.id JOIN user_account u ON b.user_id = u.id
        WHERE u.id = ?
      `;
    }
    // code from here applies to any page displaying bookings with a filter on it
    // add the selection criteria for selecting bookings on the selected date
    if (filters.date != "")
      sqlquery =
        sqlquery +
        ` 
    AND (
      b.booking_start >= DATE_ADD('` +
        filters.date +
        `', INTERVAL '00:01' HOUR_MINUTE) 
      AND 
      b.booking_end <= DATE_ADD('` +
        filters.date +
        `', INTERVAL '23:59' HOUR_MINUTE)
    ) 
    `;
    // if we have a timeslot then add the selection criteria for this
    if (filters.timeslot != "-NaN:NaN") {
      // split the timeslot up so we have start and end times
      var selectedDate = filters.date;
      var timeslots = filters.timeslot.split("-");
      var startTime = timeslots[0];
      var endTime = timeslots[1];
      sqlquery =
        sqlquery +
        ` 
        AND (
          b.booking_start >= DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        startTime +
        `' HOUR_MINUTE) 
          AND 
          b.booking_end <= DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        endTime +
        `' HOUR_MINUTE)
        ) 
      `;
    }
    // add any other filters to the end of the query
    if (filters.building != "")
      sqlquery =
        sqlquery + " AND r.building_name = '" + filters.building + "' ";
    if (filters.roomType != "")
      sqlquery = sqlquery + " AND r.room_type = '" + filters.roomType + "' ";
    if (filters.minSeats != "")
      sqlquery = sqlquery + " AND r.capacity >=  '" + filters.minSeats + "' ";
    // add the "order by" string
    sqlquery = sqlquery + " " + listOrder;
    // console.log("get bookings sql: " + sqlquery);
    // execute sql query
    db.query(sqlquery, [userId], (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err); // if there is an error reject the Promise
      } else {
        resolve(results); // the Promise is resolved with the result of the query
      }
    });
  });
}

// gets the roomtypes to be displayed in the filter from the database
// some pages require all the roomtypes, others require this list to be filtered
// this function uses a Promise, which means that the code waits for a result when
// used with promise all in the route code.
function getRoomTypes(pageName, userId) {
  return new Promise((resolve, reject) => {
    sqlquery = "";
    if (pageName === "bookings-list") {
      // only get the room types that the logged in user has made bookings for
      sqlquery =
        "SELECT DISTINCT r.room_type as room_type FROM room r JOIN booking b ON b.room_id = r.id JOIN user_account u ON b.user_id = u.id WHERE u.id = ? ORDER BY room_type";
    } else {
      // get all room_types that have had a booking from any user
      sqlquery =
        "SELECT DISTINCT r.room_type as room_type FROM room r JOIN booking b ON b.room_id = r.id ORDER BY room_type";
    }
    // execute sql query
    db.query(sqlquery, [userId], (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err); // if there is an error reject the Promise
      } else {
        resolve(results); // the Promise is resolved with the result of the query
      }
    });
  });
}

// gets the buildings to be displayed in the filter
// some pages require all the rooms, others require this list to be filtered
function getBuildingNames(pageName, userId) {
  return new Promise((resolve, reject) => {
    sqlquery = "";
    if (pageName === "bookings-list") {
      // only get the buildings that the logged in user has made bookings for
      sqlquery =
        "SELECT DISTINCT r.building_name as building_name FROM room r JOIN booking b ON b.room_id = r.id JOIN user_account u ON b.user_id = u.id WHERE u.id = ? ORDER BY building_name";
    } else {
      // get all buildings that have had a booking from any user
      sqlquery =
        "SELECT DISTINCT r.building_name as building_name FROM room r JOIN booking b ON b.room_id = r.id ORDER BY building_name";
    }
    // execute sql query
    db.query(sqlquery, [userId], (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err); // if there is an error reject the Promise
      } else {
        resolve(results); // the Promise is resolved with the result of the query
      }
    });
  });
}

// get rooms the database for the book room page, and also apply filters if there are any
// if there is a date and a timeslot filled in then remove any rooms that have a booking that
// overlaps with the date and times we looking for
function getRooms(filters, listOrder) {
  return new Promise((resolve, reject) => {
    var sqlquery = "";
    // if the filter date OR there is no selecton for start time and duration then get all the rooms and other filter criteria are added after the if else
    if (filters.date == "" || filters.timeslot == "-NaN:NaN") {
      sqlquery = `
          SELECT r.id as roomId, r.room_number as roomNumber, r.building_name as building, r.capacity as capacity,
          r.picture_URL as pictureURL, r.room_type as roomType
          FROM room r WHERE r.is_accepting_bookings = 1 `;
    } else {
      // if we have a data and a timeslot do all the work to remove rooms that are already booked for the date, duration and timeslots in the filter
      // this needs a version of ben's code in the app post bookings-list-filtered to extract these values from the filter
      var selectedDate = filters.date;
      var timeslots = filters.timeslot.split("-");
      var startTime = timeslots[0];
      var endTime = timeslots[1];
      // calclate duration in mins from the filter timeslot
      var intStartTime = timeslots[0].split(":").map(Number);
      var durationStart = intStartTime[0] * 60 + intStartTime[1];
      var intEndTime = timeslots[1].split(":").map(Number);
      var durationEnd = intEndTime[0] * 60 + intEndTime[1];
      var overallDuration = durationEnd - durationStart;
      sqlquery =
        `
      SELECT r.id as roomId, r.room_number as roomNumber, r.building_name as building, r.capacity as capacity,
      r.picture_URL as pictureURL, r.room_type as roomType  
      FROM room r
      # If there are ANY number of bookings for this room that start before the timeslot
      # and end after the timeslot exclude the room.  The fixes the issue where multiple bookings on
      # a room in the timescale could create duplicate rooms.  Which would have happened if we joined rooms and bookings
      WHERE NOT EXISTS (
        SELECT 1
        FROM booking b
        WHERE b.room_id = r.id
        AND (
              (
                b.booking_start < DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        startTime +
        `' HOUR_MINUTE) 
                AND 
                b.booking_end > DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        endTime +
        `' HOUR_MINUTE)
              )
        )
      )   
      # from that list above
      # exlude any room that has a booking that starts before the timeslot and finishes after the timeslot
      # OR exclude any room that has a booking that overlaps with the timeslot
      AND r.id NOT IN (
        SELECT room_id
        FROM booking
        WHERE DATE(booking_start) = '` +
        selectedDate +
        `'
        AND (
              (
                booking_start < DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        startTime +
        `' HOUR_MINUTE) 
                AND 
                booking_end > DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        endTime +
        `' HOUR_MINUTE)
              )
            OR (
              booking_end > DATE_ADD(booking_start, INTERVAL '` +
        overallDuration +
        `' MINUTE)
              AND booking_start <= DATE_ADD('` +
        selectedDate +
        `', INTERVAL '` +
        startTime +
        `' HOUR_MINUTE)
            )
        )
      ) AND r.is_accepting_bookings = 1 `;
    }
    // add any other filters to the end of the query
    if (filters.building != "")
      sqlquery =
        sqlquery + " AND r.building_name = '" + filters.building + "' ";
    if (filters.roomType != "")
      sqlquery = sqlquery + " AND r.room_type = '" + filters.roomType + "' ";
    if (filters.minSeats != "")
      sqlquery = sqlquery + " AND r.capacity >=  '" + filters.minSeats + "' ";
    // add the "order by" string
    sqlquery = sqlquery + " " + listOrder;

    // execute sql query
    // console.log("getRooms sqlquery: " + sqlquery);
    db.query(sqlquery, (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err); // if there is an error reject the Promise
      } else {
        resolve(results); // the Promise is resolved with the result of the query
      }
    });
  });
}

// sort booking functions:
function sortByBuilding(bookings) {
  bookings.sort(function (a, b) {
    // sort by rooms alphabetically:
    if (a.building < b.building) {
      return -1;
    }
    if (a.building > b.building) {
      return 1;
    }
    // If the bookings are in the same building sort by room number:
    if (a.building === b.building) {
      return a.roomNumber - b.roomNumber;
    }
  });
  return bookings;
}
function sortByTime(bookings) {
  bookings.sort(function (a, b) {
    // Convert the date strings into date objects:
    var aDateSplit = a.date.split("/"); // form is YYYY/MM/DD - split at "/"
    var bDateSplit = b.date.split("/");
    var aDate = new Date(
      parseInt(aDateSplit[0]),
      parseInt(aDateSplit[1]) - 1,
      parseInt(aDateSplit[2])
    );
    var bDate = new Date(
      parseInt(bDateSplit[0]),
      parseInt(bDateSplit[1]) - 1,
      parseInt(bDateSplit[2])
    );
    // Compare the dates
    if (aDate < bDate) {
      return -1;
    }
    if (aDate > bDate) {
      return 1;
    }
    // If the dates the same date then order by ascending timeslots from starting time
    var startingTimeA = a.timeslot.split("-")[0]; // remove central dash and second time
    var startingTimeB = b.timeslot.split("-")[0];
    var aTimeSlot = parseInt(startingTimeA.split(":")[0]);
    var bTimeSlot = parseInt(startingTimeB.split(":")[0]);
    return aTimeSlot - bTimeSlot;
  });
  return bookings;
}
function sortByStatus(bookings) {
  // sorts bookings as follows - Approved, Awaiting Approval, Denied
  var sortedBookings = [];
  var awaitingApprovalBookings = [];
  for (let i = 0; i < bookings.length; i++) {
    switch (bookings[i].Status) {
      case "Approved":
        sortedBookings.unshift(bookings[i]);
        break;
      case "Awaiting Approval":
        awaitingApprovalBookings.push(bookings[i]);
        break;
      case "Denied":
        sortedBookings.push(bookings[i]);
        break;
    }
  }
  var lastApproved = -1;
  for (let i = 0; i < sortedBookings.length; i++) {
    if (sortedBookings[i].Status !== "Approved") {
      lastApproved = i;
      break;
    }
  }
  // insert the awaiting approval bookings at the appropriate index:
  Array.prototype.splice.apply(
    sortedBookings,
    [lastApproved, 0].concat(awaitingApprovalBookings)
  );
  return sortedBookings;
}
/*  converted to new version - new code under this code
app.get("/bookings-list", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  // get all the database result sets that are required for this page
  // get them from asynchronus functions so they can be re-used
  // on different pages, pass the function requests in an array as part of Promise.all
  Promise.all([
    getRoomTypes("bookings-list", userId),           // Promise.all[0]
    getBuildingNames("bookings-list", userId),       // Promise.all[1]
    getBookings("bookings-list",userId)              // Promise.all[2]
  ])
  .then(([roomTypes, buildingNames, bookings]) => {           // if you had more data just add the name of it here first variable is the result of promise.all[0] etc.
    res.render("bookings-list.ejs", {
      loggedInMessage,
      userrole,
      email,
      bookings,
      roomTypes,
      buildingNames
    });
  })
  .catch(error => {
    console.log("Error getting data from database calls or in the code above");
  });
  filteredBookingsGlobal = [];
});

app.post("/bookings-list", isLoggedIn, function (req, res) {
  console.log(req.body); // Add this line
  var loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  Promise.all([
    getRoomTypes("bookings-list", userId ),             // Promise.all[0]
    getBuildingNames("bookings-list", userId),          // Promise.all[1]
    getBookings("bookings-list", userId)                // Promise.all[2]
  ])
  .then(([roomTypes, buildingNames, bookings]) => {             // if you had more data just add the name of it here first variable is the result of promise.all[0] etc.
    if (filteredBookingsGlobal.length > 0){
        bookings = filteredBookingsGlobal;
    }
    // Your existing sorting logic here...
    switch (req.body.orderSelection) {
      case "o_b_Room":
          bookings = sortByBuilding(bookings);
          break;
      case "o_b_Time":
          bookings = sortByTime(bookings);
          break;
      case "o_b_Status":
          bookings = sortByStatus(bookings);
          break;
      default:
          console.log("Invalid input for ordering bookings");
          res.send("Invalid input for ordering bookings");
          return;
    }

    res.render("bookings-list.ejs", {
      loggedInMessage,
      userrole,
      email,
      bookings,
      roomTypes,
      buildingNames
    });
  })
  .catch(error => {
    console.log("Error getting data from database calls or in the code above");
  });
});

var filteredBookingsGlobal = [];
app.post("/bookings-list-filtered", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  var queryProcess;
  var startingTimeslot = req.body.timeslot.replace("starting from ", "");
  var bookingDuration = req.body.durationRange;
  var bookingHours = Math.floor(bookingDuration / 60);
  var bookingMinutes = bookingDuration % 60;
  var startingTimeSplit = startingTimeslot.split(":");
  var endingTimeslot =
    String(parseInt(startingTimeSplit[0]) + bookingHours).padStart(2, "0") +
    ":" +
    String(parseInt(startingTimeSplit[1]) + bookingMinutes).padStart(2, "0");
  var filters = {
    date: req.body.date,
    timeslot: startingTimeslot + "-" + endingTimeslot,
    building: req.body.building,
    roomType: req.body.roomType,
    minSeats: req.body.seating,
    duration: req.body.durationRange,
  };

  Promise.all([
    getRoomTypes("bookings-list", userId),           // Promise.all[0]
    getBuildingNames("bookings-list", userId),       // Promise.all[1]
    getBookings("bookings-list", userId),            // Promise.all[2]
  ])
  .then(([roomTypes, buildingNames, bookings]) => {           // if you had more data calls above you name it here, the first variable is the result of promise.all[0] etc.
    //console.log(bookings);
    console.log(filters);
    var filteredBookings = [];
    for (var i = 0; i < bookings.length; i++) {
      //console.log(bookings[i]);
      if (bookings[i].date != filters.date && filters.date != "") {
        //console.log("date failed: " + bookings[i].date);
        continue;
      }
      if (
        bookings[i].timeslot != filters.timeslot &&
        filters.timeslot != "-NaN:NaN"
      ) {
        //console.log("timeslot failed: " + bookings[i].timeslot);
        continue;
      } else if (filters.duration > 0) {
        var bookingTimeslot = bookings[i].timeslot.split("-");
        var bookingStartTime = bookingTimeslot[0].split(":").map(Number);
        //console.log(bookingStartTime);
        var bookingStart = bookingStartTime[0] * 60 + bookingStartTime[1];
        var bookingEndTime = bookingTimeslot[1].split(":").map(Number);
        //console.log(bookingEndTime);
        var bookingEnd = bookingEndTime[0] * 60 + bookingEndTime[1];
        var overallDuration = bookingEnd - bookingStart;
        //console.log(i + "; " + overallDuration);
        if (overallDuration != filters.duration) {
          //console.log("duration failed: " + overallDuration);
          continue;
        }
      }
      if (bookings[i].building != filters.building && filters.building != "") {
        //console.log("building failed: " + bookings[i].building);
        continue;
      }
      if (bookings[i].roomType != filters.roomType && filters.roomType != "") {
        //console.log("roomtype failed: " + bookings[i].roomType);
        continue;
      }
      if (bookings[i].minSeats <= filters.minSeats && filters.minSeats >= 1) {
        //console.log("min seats failed: " + bookings[i].minSeats);
        continue;
      }
      //console.log("added: " + bookings[i]);
      filteredBookings.push(bookings[i]);
    }
    bookings = filteredBookings;
    filteredBookingsGlobal = filteredBookings;
    res.render("bookings-list.ejs", {
      loggedInMessage,
      userrole,
      email,
      bookings,
      roomTypes,
      buildingNames
    });
  })
  .catch(error => {
    console.log("Error getting data from database calls or in the code above");
  });
  //res.send(filteredBookings);
});
*/

// new booking list version
app.get("/bookings-list", isLoggedIn, (req, res) => {
  var loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  // get the filters from the user session, else initialise the filters
  var filters = {};
  if (req.session.bookingListFilters) filters = req.session.bookingListFilters;
  else {
    filters = {
      date: "",
      timeslot: "-NaN:NaN",
      building: "",
      roomType: "",
      minSeats: 1,
      duration: "",
    };
    // save the current filters in the user session
    req.session.bookingListFilters = filters;
  }
  // manage the ordering of the data - if the user has re-ordered the list
  var listOrder = "";
  switch (req.session.bookingListOrder) {
    case "o_b_Room":
      listOrder = " ORDER BY r.building_name, r.room_number";
      break;
    case "o_b_Time":
      listOrder = " ORDER BY b.booking_start";
      break;
    case "o_b_Status":
      listOrder = " ORDER BY b.booking_status";
      break;
    default:
      listOrder = " ORDER BY b.booking_start";
      break;
  }
  Promise.all([
    getRoomTypes("bookings-list", userId), // Promise.all[0]
    getBuildingNames("bookings-list", userId), // Promise.all[1]
    getBookings("bookings-list", userId, filters, listOrder), // Promise.all[2]
  ])
    .then(([roomTypes, buildingNames, bookings]) => {
      // if you had more data just add the name of it here first variable is the result of promise.all[0] etc.
      res.render("bookings-list.ejs", {
        loggedInMessage,
        userrole,
        email,
        bookings,
        roomTypes,
        buildingNames,
      });
    })
    .catch((error) => {
      console.log(
        "Error getting data from database calls or in the code above"
      );
    });
});

// this route is re-used for filtering AND ordering, if there no req.body.orderSelection
// then we are processing filtering, otherwise we are processing ordering
app.post("/bookings-list-filtered", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  var filters = {};
  // work out if we are posting to filter the list or order the list
  // if the POST doesn't contain req.body.orderSelection then we are have a post that is filtering
  if (!req.body.orderSelection) {
    var startingTimeslot = req.body.timeslot.replace("starting from ", "");
    var bookingDuration = req.body.durationRange;
    var bookingHours = Math.floor(bookingDuration / 60);
    var bookingMinutes = bookingDuration % 60;
    var startingTimeSplit = startingTimeslot.split(":");
    var endingTimeslot =
      String(parseInt(startingTimeSplit[0]) + bookingHours).padStart(2, "0") +
      ":" +
      String(parseInt(startingTimeSplit[1]) + bookingMinutes).padStart(2, "0");
    filters = {
      date: req.body.date,
      timeslot: startingTimeslot + "-" + endingTimeslot,
      building: req.body.building,
      roomType: req.body.roomType,
      minSeats: req.body.seating,
      duration: req.body.durationRange,
    };
    // save the current filters in the user session, this is so they can be re-used when there is no filter POSTED
    req.session.bookingListFilters = filters;
  } else {
    filters = req.session.bookingListFilters;
    // save the orderSelection
    req.session.bookingListOrder = req.body.orderSelection;
  }
  // get the current list order from the session and if not present initialise the order
  // if (!req.session.bookingListOrder) req.session.bookingListOrder = ""
  // manage the ordering of the data - if the user has re-ordered the list
  var listOrder = "";
  //console.log("session.roomListOrder: " + req.session.bookingListOrder);
  switch (req.session.bookingListOrder) {
    case "o_b_Room":
      listOrder = " ORDER BY r.building_name, r.room_number";
      break;
    case "o_b_Time":
      listOrder = " ORDER BY b.booking_start";
      break;
    case "o_b_Status":
      listOrder = " ORDER BY b.booking_status";
      break;
    default:
      listOrder = " ORDER BY b.booking_start";
      break;
  }
  Promise.all([
    getRoomTypes("booking-list", userId), // Promise.all[0]
    getBuildingNames("booking-list", userId), // Promise.all[1]
    getBookings("bookings-list", userId, filters, listOrder), // Promise.all[2]
  ])
    .then(([roomTypes, buildingNames, bookings]) => {
      // if you had more data calls above you name it here, the first variable is the result of promise.all[0] etc.
      console.log(filters);
      res.render("bookings-list.ejs", {
        loggedInMessage,
        userrole,
        email,
        bookings,
        roomTypes,
        buildingNames,
      });
    })
    .catch((error) => {
      console.log(
        "Error getting data from database calls or in the code above"
      );
    });
});

//this route is used to display the add-room page
app.get("/add-room", isLoggedIn, (req, res) => {
  // checking for admin role
  if (req.session.user_role !== "admin") {
    return res.send("Unauthorized access");
  }

  // get the room types from the database
  const query = "SELECT room_type FROM lookup_room_type";
  db.query(query, (err, roomTypes) => {
    if (err) {
      console.error(err.message);
      return res.send("Error fetching room types");
    }
    // pass the roomTypes to the add-room page
    res.render("add-room", { roomTypes: roomTypes });
  });
});

// this route is used to add a room to the database
app.post("/add-room", isLoggedIn, (req, res) => {
  // checking for admin role
  if (req.session.user_role !== "admin") {
    return res.send("Unauthorized access");
  }

  // sanitising the input
  const roomNumber = sanitiseHtml(req.body.roomNumber);
  const buildingName = sanitiseHtml(req.body.buildingName);
  const roomType = sanitiseHtml(req.body.roomType);
  const capacity = parseInt(req.body.capacity);
  const pictureURL = sanitiseHtml(req.body.pictureURL);
  const isAcceptingBookings = req.body.isAcceptingBookings === "true";

  // inserting the room into the database
  let sqlquery =
    "INSERT INTO room (room_number, building_name, room_type, capacity, picture_URL, is_accepting_bookings) VALUES (?, ?, ?, ?, ?, ?)";

  // execute sql query
  db.query(
    sqlquery,
    [
      roomNumber,
      buildingName,
      roomType,
      capacity,
      pictureURL,
      isAcceptingBookings,
    ],
    (err, result) => {
      if (err) {
        console.error(err.message);
        return res.send("Error in adding room");
      }
      // redirecting to a success page if the room was added successfully
      res.redirect("/add-room-success");
    }
  );
});


//----------------------------------------VIEW BOOKING--------------------------------------------------------
app.get("/view-booking", isLoggedIn, (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  //console.log(loggedInMessage + " " + userrole);
  res.render("view-booking.ejs", { loggedInMessage, userrole, email });
});

function getBookingById(bookingId) {
  return new Promise((resolve, reject) => {
      const query = 'SELECT * FROM booking WHERE id = ?';
      db.query(query, [bookingId], (error, results) => {
          if (error) {
              reject(error);
          } else {
              if (results.length > 0) {
                  resolve(results[0]); // Assuming booking ID is unique
              } else {
                  resolve(null); // No booking found for the given ID
              }
          }
      });
  });
}


app.get("/view-booking/:id", isLoggedIn, (req, res) => {  
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  //console.log(loggedInMessage + " " + userrole);
  
    try{
    // get the booking id from the url
    const bookingId = req.params.id;
    getBookingById(bookingId);
      const query =
    `
        SELECT 
        r.room_number as roomNumber, 
        r.building_name as building, r.capacity as minSeats,
        r.room_type as roomType, 
        DATE_FORMAT(b.booking_start, '%Y-%m-%d') as date,
        CONCAT(DATE_FORMAT(b.booking_start, '%H'),
        ':',
        DATE_FORMAT(b.booking_start,'%i'),
        '-',
        DATE_FORMAT(b.booking_end, '%H'),
        ':'
        ,DATE_FORMAT(b.booking_end,'%i')) as timeslot,
        r.picture_URL as pictureURL, 
        u.email as bookedBy, 
        b.booking_status as Status,
        b.id as bookingId, 
        r.id as roomId, 
        u.id as userId
        FROM booking b
        JOIN user_account u ON b.user_id = u.id
        JOIN room r ON b.room_id = r.id
        LEFT JOIN risk_assessment ra ON b.id = ra.booking_id
        WHERE b.id = ?
      `;

    db.query(query, [bookingId], (err, result) => {
      if(err){
        console.log("WHAT THE HECK")
      } else{
        //var bookingDetails = result;
        console.log(result);
        //res.send(result);
        //bookingDetails = Object.assign({}, { loggedInMessage }, { userrole }, { email }, { result });
        res.render("view-booking.ejs", {loggedInMessage, userrole, email, result});
      }
    })
    // }
    // console.log(bookingDetails);
    // if(bookingDetails) {
    //   // res.render("view-booking.ejs", {bookingDetails});
    //   res.send(bookingDetails);

    // } else{
    //   res.render ("bookings-list.ejs");
  } catch(error){
  console.error("Error retrieving booking details:", error);
 /*  res.status(500).send("Internal Server Error"); */
  }  
});

app.get("/edit-booking", isLoggedIn, (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  //console.log(loggedInMessage + " " + userrole);
  res.render("edit-booking.ejs", { loggedInMessage, userrole, email });
});

// this displays the room details from the database and the
// booking information passed into the page from the room-list is roomId, selectedDate and selectedTimeSlot
app.post("/add-booking", isLoggedIn, (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  // console.log("add_booking email: " + req.session.email + "userrole: " + req.session.user_role);
  // get the data from the URL that is POSTED to this page
  var roomId = req.body.roomId;
  var selectedDate = req.body.selectedDate;
  var selectedTimeslot = req.body.selectedTimeslot;
  // get the room data - we have the userrole and the email aready from the session data
  let sqlquery = `
    SELECT  r.id AS roomId, r.room_number AS roomNumber, r.building_name AS building, 
            r.capacity AS capacity, r.picture_URL AS pictureURL, 
            r.room_type AS roomType
    FROM room r 
    WHERE r.id = ?`;
  // note for view-bookings
  // For getting all the fields from the booking once it's created - this is for view-booking etc
  // this is SQL that you can paste into msql command line - this needs the final line to be
  // passed bookingId
  // `SELECT  r.id AS roomId, r.room_number AS roomNumber, r.building_name AS building,
  // r.capacity AS capacity, r.picture_URL AS pictureURL, ra.risk1, ra.risk2, b.booking_status,
  // # add other fields from booking (b) and risk_assessment (ra) as needed
  // r.room_type AS roomType
  // FROM room r JOIN booking b ON b.room_id = r.id LEFT JOIN risk_assessment ra ON ra.booking_id = b.id
  // WHERE b.id = 30;`

  // execute sql query
  db.query(sqlquery, roomId, (err, result) => {
    if (err) {
      console.log("add-booking db query error");
      console.error(err.message);
      res.render("/bookings-list");
    }
    let pageData = Object.assign(
      {},
      { loggedInMessage },
      { userrole },
      { email },
      { room: result },
      { selectedDate },
      { selectedTimeslot }
    );
    res.render("add-booking.ejs", pageData);
  });
});

/**
 * Inserts or updates a booking.
 * the mode parameter is checked and based on that different SQL can be run
 * this was implemented as a function so it can return the id of any insert that it performs
 * but it can also be used for updates it can be used in a Promise.All if the queries can come back in any order
 * or it can be used
 * @param {*} mode                 mode can be INSERT or UPDATE_STATUS or UPDATE_RISK_ASSESS_APPROVAL
 * @param {*} changedDataFields    Array: The fields, in order, that are to replaced the SQLQuery parameters
 * @returns                        id of record inserted only if this is an insertion, else returns the record set
 */
function insertUpdateBooking(mode, changedDataFields) {
  return new Promise((resolve, reject) => {
    var sqlquery = "";
    if (mode == "INSERT") {
      sqlquery = `
        INSERT INTO booking 
          (booking_start, booking_end, booking_reason, booking_status,
          is_risk_assessment_approved, confirmed_on, cancelled_on, user_id, room_id)
          VALUES (
          ?, ?, NULL, "Awaiting Approval",
          0, NULL, NULL, ?, ?)
        `;
    }
    if (mode == "UPDATE_STATUS") {
      sqlquery = `
        UPDATE booking SET booking_status = ? where id = ?' 
      `;
    }
    if (mode == "UPDATE_RISK_ASSESS_APPROVAL") {
      sqlquery = `
        UPDATE booking SET is_risk_assessemnt_approved = ? where id = ?' 
      `;
    }
    console.log("insertUpdateBooking: " + sqlquery);
    // add more modes here as necessary
    // execute sql query
    db.query(sqlquery, changedDataFields, (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err); // if there is an error reject the Promise
      } else {
        if (mode == "INSERT") {
          resolve(results.insertId); // this returns the id for the record inserted which we can use in other queries
        } else {
          resolve(results);
        }
      }
    });
  });
}

/**
 * Inserts or updates a risk assessment.
 * the mode parameter is checked and based on that different SQL can be run
 * this was implemented as a function so it can return the id of any insert that it performs
 * but it can also be used for updates it can be used in a Promise.All if the queries can come back in any order
 * or it can be used
 * @param {*} mode                 mode can be INSERT
 * @param {*} changedDataFields    Array: The fields, in order, that are to replaced the SQLQuery parameters
 * @returns                        record set from the database
 */
// inserts the new risk assessment, same logic as insertUpdateBooking
function insertUpdateRiskAssessment(mode, changedDataFields) {
  return new Promise((resolve, reject) => {
    var sqlquery = "";
    if (mode == "INSERT") {
      sqlquery = `
        INSERT INTO risk_assessment 
          (risk1, risk2, is_approved, approved_by, booking_id)
        VALUES (?, ?, 0, NULL, ?)
      `;
    }
    // add more modes here as necessary for updating etc
    // execute sql query
    console.log("insertUpdateRiskAssessment: " + sqlquery);
    db.query(sqlquery, changedDataFields, (err, results) => {
      if (err) {
        console.error(err.message);
        reject(err); // if there is an error reject the Promise
      } else {
        resolve(results); // the Promise is resolved with the result of the query
      }
    });
  });
}

// this processes the booking when the confirm button is pressed
app.post("/add-booking-submit", isLoggedIn, (req, res) => {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  var userId = req.session.userid;

  // sanitising the input
  const selectedDate = sanitiseHtml(req.body.selectedDate);
  const selectedTimeslot = sanitiseHtml(req.body.selectedTimeslot);
  const roomId = sanitiseHtml(req.body.roomId);
  const bookingStart = selectedDate + " " + selectedTimeslot.split("-")[0];
  const bookingEnd = selectedDate + " " + selectedTimeslot.split("-")[1];
  const risk1 = sanitiseHtml(req.body.risk1);
  const risk2 = sanitiseHtml(req.body.risk2);
  //console.log("selected timeslot:" + selectedTimeslot);
  //console.log("booking start: " + bookingStart);
  //console.log("booking end: " + bookingEnd);
  var bookingData = [bookingStart, bookingEnd, userId, roomId];
  var riskAssessmentData = [risk1, risk2];
  //console.log("booking data: " + bookingData);
  //console.log("riskAssessmentData data: " + riskAssessmentData);

  // these updates need to happen sequentially so this doesn't use promise.all
  // the booking needs to be created and then the id that was just created in the booking table
  // needs to be used to then create the risk assessment table entry
  // there are two functions the first is called (it returns bookingId)
  // then this is used for the second function
  insertUpdateBooking("INSERT", bookingData)
    .then((bookingId) => {
      // add the bookingId that has been returned from the booking insert to the end of the
      // data passed to the insertUpdateRiskAssessment
      riskAssessmentData.push(bookingId);
      return insertUpdateRiskAssessment("INSERT", riskAssessmentData);
    })
    .then((riskAssessmentResult) => {
      console.log("Risk assessment updated with result:", riskAssessmentResult);
      res.send(
        '<p>Booking and risk assessment inserted successfully!</p></br><a href="/login-success">Click to go back to the menu</a>'
      );
    })
    .catch((error) => {
      console.error("An error occurred:", error);
    });
});

//this route displays when a room has been added successfully
app.get("/add-room-success", isLoggedIn, (req, res) => {
  res.send(
    '<p>Room added successfully!</p><a href="/login-success">Return to Dashboard</a>'
  );
});

// this is the route that displays all the rooms so a user can select one and make a booking - renamed from book-room to match other list pages
app.get("/rooms-list", isLoggedIn, (req, res) => {
  var loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  // get the filters from the user session, else initialise the filters
  var filters = {};
  if (req.session.roomListFilters) filters = req.session.roomListFilters;
  else {
    filters = {
      date: "",
      timeslot: "-NaN:NaN",
      building: "",
      roomType: "",
      minSeats: 1,
      duration: "",
    };
    // save the current filters in the user session
    req.session.roomListFilters = filters;
  }
  // manage the ordering of the data - if the user has re-ordered the list
  var listOrder = "";
  switch (req.session.roomListOrder) {
    case "o_b_Capacity":
      listOrder = " ORDER BY r.capacity DESC";
      break;
    case "o_b_Building":
      listOrder = " ORDER BY r.building_name, r.room_number";
      break;
    default:
      listOrder = " ORDER BY r.building_name, r.room_number";
      break;
  }
  // if the filter has a date and a timeslot then create a string to be passed to the page which gets shown inside the book button
  var selectedTimeslot = "";
  var selectedDate = "";
  if (filters.timeslot != "-NaN:NaN" && filters.date != "") {
    selectedTimeslot = filters.timeslot;
    selectedDate = filters.date;
  }
  Promise.all([
    getRoomTypes("rooms-list", userId), // Promise.all[0]
    getBuildingNames("rooms-list", userId), // Promise.all[1]
    getRooms(filters, listOrder), // Promise.all[2]
  ])
    .then(([roomTypes, buildingNames, rooms]) => {
      // if you had more data just add the name of it here first variable is the result of promise.all[0] etc.
      res.render("rooms-list.ejs", {
        loggedInMessage,
        userrole,
        email,
        rooms,
        roomTypes,
        buildingNames,
        selectedTimeslot,
        selectedDate,
      });
    })
    .catch((error) => {
      console.log(
        "Error getting data from database calls or in the code above"
      );
    });
});

// route for the filter and ordering in the rooms-list page
// this route is re-used for filtering AND ordering, if there no req.body.orderSelection
// then we are processing filtering, otherwise we are processing ordering
app.post("/rooms-list-filtered", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var userId = req.session.userid;
  var email = req.session.email;
  var filters = {};
  // work out if we are posting to filter the list or order the list
  // if the POST doesn't contain req.body.orderSelection then we are have a post that is filtering
  if (!req.body.orderSelection) {
    var startingTimeslot = req.body.timeslot.replace("starting from ", "");
    var bookingDuration = req.body.durationRange;
    var bookingHours = Math.floor(bookingDuration / 60);
    var bookingMinutes = bookingDuration % 60;
    var startingTimeSplit = startingTimeslot.split(":");
    var endingTimeslot =
      String(parseInt(startingTimeSplit[0]) + bookingHours).padStart(2, "0") +
      ":" +
      String(parseInt(startingTimeSplit[1]) + bookingMinutes).padStart(2, "0");
    filters = {
      date: req.body.date,
      timeslot: startingTimeslot + "-" + endingTimeslot,
      building: req.body.building,
      roomType: req.body.roomType,
      minSeats: req.body.seating,
      duration: req.body.durationRange,
    };
    // save the current filters in the user session, this is so they can be re-used when there is no filter POSTED
    req.session.roomListFilters = filters;
  } else {
    filters = req.session.roomListFilters;
    // save the orderSelection
    req.session.roomListOrder = req.body.orderSelection;
  }
  // get the current list order from the session and if not present initialise the order
  // if (!req.session.roomListOrder) req.session.roomListOrder = ""
  // manage the ordering of the data - if the user has re-ordered the list
  var listOrder = "";
  //console.log("session.roomListOrder: " + req.session.roomListOrder);
  switch (req.session.roomListOrder) {
    case "o_b_Capacity":
      listOrder = " ORDER BY r.capacity DESC";
      break;
    case "o_b_Building":
      listOrder = " ORDER BY r.building_name, r.room_number";
      break;
    default:
      listOrder = " ORDER BY r.building_name, r.room_number";
      break;
  }
  var selectedTimeslot = "";
  var selectedDate = "";
  if (filters.timeslot != "-NaN:NaN" && filters.date != "") {
    selectedTimeslot = filters.timeslot;
    selectedDate = filters.date;
  }
  console.log(filters);
  Promise.all([
    getRoomTypes("rooms-list", userId), // Promise.all[0]
    getBuildingNames("rooms-list", userId), // Promise.all[1]
    getRooms(filters, listOrder), // Promise.all[2]
  ])
    .then(([roomTypes, buildingNames, rooms]) => {
      // if you had more data calls above you name it here, the first variable is the result of promise.all[0] etc.
      console.log(filters);
      res.render("rooms-list.ejs", {
        loggedInMessage,
        userrole,
        email,
        rooms,
        roomTypes,
        buildingNames,
        selectedTimeslot,
        selectedDate,
      });
    })
    .catch((error) => {
      console.log(
        "Error getting data from database calls or in the code above"
      );
    });
});

app.get("/view-requests", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  //console.log(loggedInMessage + " " + userrole);
  var bookings = [];
  // temporarily fill bookings:
  var tempBooking = {
    roomNumber: 256,
    building: "RHB",
    date: "16 Jan 2024",
    timeslot: "10:00-12:00",
    bookedBy: "Emily Rain",
    Status: "Awaiting Approval",
  };
  for (let i = 0; i < 5; i++) {
    bookings.push(tempBooking);
  }
  res.render("view-requests.ejs", {
    loggedInMessage,
    userrole,
    email,
    bookings,
  });
});

app.get("/view-accepted", isLoggedIn, function (req, res) {
  loggedInMessage = getLoggedInUser(req);
  var userrole = req.session.user_role;
  var email = req.session.email;
  //console.log(loggedInMessage + " " + userrole);
  var bookings = [];
  // temporarily fill bookings:
  var tempBooking = {
    roomNumber: 256,
    building: "RHB",
    date: "16 Jan 2024",
    timeslot: "10:00-12:00",
    bookedBy: "Emily Rain",
    Status: "Awaiting Approval",
  };
  for (let i = 0; i < 5; i++) {
    bookings.push(tempBooking);
  }
  res.render("view-accepted.ejs", {
    loggedInMessage,
    userrole,
    email,
    bookings,
  });
});

//edit room page to edit room using code from view bookings and add room

app.get("/edit-room", isLoggedIn, (req, res) => {
  // checking for admin role
  if (req.session.user_role !== "admin") {
    return res.send("Unauthorized access");
  }

  // get the room types from the database
  const query = "SELECT * from room;";

  db.query(query, (err, rooms) => {
    if (err) {
      console.error(err.message);
      return res.send("Error fetching room types");
    }
    // pass the roomTypes to the add-room page
    res.render("edit-room", { rooms: rooms });
  });
});

app.post("/edit-room-success", isLoggedIn, (req, res) => {
  //sql changes to room table


  // commentted for now
  //sqlquery =
  //  "UPDATE room SET room_number = ?, building_name = ?, room_type = ?, capacity = ?, picture_URL = ?, is_accepting_bookings = ? WHERE room_number = ' " +
  //  req.body.roomNumber +
  //  "';";
  db.query(
    sqlquery,
    [
      req.body.roomNumber,
      req.body.buildingName,
      req.body.roomType,
      req.body.capacity,
      req.body.pictureURL,
      req.body.isAcceptingBookings,
    ],
    (err, result) => {
      if (err) {
        console.error(err.message);
        return res.send("Error in updating room");
      }
      // redirecting to a success page if the room was added successfully
      res.send("Room updated successfully");
    }
  );
});

// app.get("/edit-room", isLoggedIn, (req, res) => {
//   // checking for admin role
//   if (req.session.user_role !== "admin") {
//     return res.send("Unauthorized access");
//   }

//   // get the room types from the database
//   const query = "SELECT room_type FROM lookup_room_type";
//   db.query(query, (err, roomTypes) => {
//     if (err) {
//       console.error(err.message);
//       return res.send("Error fetching room types");
//     }
//     // pass the roomTypes to the add-room page
//     res.render("edit-room", { roomTypes: roomTypes });
//   });
// });

app.listen(port, () => {
  console.log(`Bookit app listening at http://localhost:${port}`);
});
